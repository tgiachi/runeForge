using System.Text;
using Runeforge.Engine.Data.Internal.Scripts;

namespace Runeforge.Engine.Utils;

/// <summary>
/// Static class for generating EmmyLua definition files from script function descriptors
/// </summary>
public static class EmmyLuaDefinitionGenerator
{
    /// <summary>
    /// Generates EmmyLua definition content from a list of script function descriptors
    /// </summary>
    /// <param name="descriptors">List of script function descriptors</param>
    /// <param name="enums">Optional list of enum types to include in definitions</param>
    /// <returns>EmmyLua definition file content as string</returns>
    public static string GenerateDefinitions(List<ScriptFunctionDescriptor> descriptors, List<Type>? enums = null)
    {
        ArgumentNullException.ThrowIfNull(descriptors);

        var moduleGroups = descriptors
            .GroupBy(d => d.ModuleName)
            .OrderBy(g => g.Key);

        var sb = new StringBuilder();

        // Add header comment
        sb.AppendLine("---@meta");
        sb.AppendLine();
        sb.AppendLine("-- Auto-generated EmmyLua definitions for Runeforge script modules");
        sb.AppendLine("-- Do not edit this file manually");
        sb.AppendLine();

        // Generate enum definitions first
        if (enums != null && enums.Count > 0)
        {
            GenerateEnumDefinitions(sb, enums);
            sb.AppendLine();
        }

        foreach (var moduleGroup in moduleGroups)
        {
            GenerateModuleDefinition(sb, moduleGroup.Key, moduleGroup.ToList(), enums);
            sb.AppendLine();
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generates EmmyLua enum definitions
    /// </summary>
    /// <param name="sb">StringBuilder to append content to</param>
    /// <param name="enums">List of enum types</param>
    private static void GenerateEnumDefinitions(StringBuilder sb, List<Type> enums)
    {
        sb.AppendLine("-- Enum Definitions");
        sb.AppendLine();

        foreach (var enumType in enums.Where(t => t.IsEnum).OrderBy(t => t.Name))
        {
            GenerateEnumDefinition(sb, enumType);
        }
    }

    /// <summary>
    /// Generates EmmyLua definition for a single enum
    /// </summary>
    /// <param name="sb">StringBuilder to append content to</param>
    /// <param name="enumType">Enum type to generate definition for</param>
    private static void GenerateEnumDefinition(StringBuilder sb, Type enumType)
    {
        var enumName = enumType.Name;
        var enumValues = Enum.GetNames(enumType);
        var enumNumericValues = Enum.GetValues(enumType);

        // Create enum table declaration
        sb.AppendLine($"---@class {enumName}");
        sb.AppendLine($"{enumName} = {{}}");
        sb.AppendLine();

        // Add enum values
        for (int i = 0; i < enumValues.Length; i++)
        {
            var valueName = enumValues[i];
            var numericValue = Convert.ToInt32(enumNumericValues.GetValue(i));

            sb.AppendLine($"--- {enumName}.{valueName} = {numericValue}");
            sb.AppendLine($"{enumName}.{valueName} = {numericValue}");
        }

        sb.AppendLine();
    }

    /// <summary>
    /// Generates EmmyLua definition for a single module
    /// </summary>
    /// <param name="sb">StringBuilder to append content to</param>
    /// <param name="moduleName">Name of the module</param>
    /// <param name="functions">List of functions in the module</param>
    /// <param name="availableEnums">Optional list of available enum types</param>
    private static void GenerateModuleDefinition(
        StringBuilder sb, string moduleName, List<ScriptFunctionDescriptor> functions, List<Type>? availableEnums = null
    )
    {
        // Module declaration
        sb.AppendLine($"---@class {moduleName}");
        sb.AppendLine($"{moduleName} = {{}}");
        sb.AppendLine();

        // Generate function definitions
        foreach (var function in functions.OrderBy(f => f.FunctionName))
        {
            GenerateFunctionDefinition(sb, moduleName, function, availableEnums);
        }
    }

    /// <summary>
    /// Generates EmmyLua definition for a single function
    /// </summary>
    /// <param name="sb">StringBuilder to append content to</param>
    /// <param name="moduleName">Name of the module containing the function</param>
    /// <param name="function">Function descriptor</param>
    /// <param name="availableEnums">Optional list of available enum types</param>
    private static void GenerateFunctionDefinition(
        StringBuilder sb, string moduleName, ScriptFunctionDescriptor function, List<Type>? availableEnums = null
    )
    {
        // Add help comment if available
        if (!string.IsNullOrEmpty(function.Help))
        {
            sb.AppendLine($"--- {function.Help}");
        }

        // Add parameter annotations
        foreach (var param in function.Parameters)
        {
            var luaType = ConvertToLuaType(param.ParameterType, availableEnums);
            sb.AppendLine($"---@param {param.ParameterName} {luaType}");
        }

        // Add return type annotation
        if (!string.IsNullOrEmpty(function.ReturnType) && function.ReturnType != "void")
        {
            var luaReturnType = ConvertToLuaType(function.ReturnType, availableEnums);
            sb.AppendLine($"---@return {luaReturnType}");
        }

        // Function declaration
        var paramNames = string.Join(", ", function.Parameters.Select(p => p.ParameterName));
        sb.AppendLine($"function {moduleName}.{function.FunctionName}({paramNames}) end");
        sb.AppendLine();
    }

    /// <summary>
    /// Converts C# type names to EmmyLua type annotations
    /// </summary>
    /// <param name="csharpType">C# type name</param>
    /// <param name="availableEnums">Optional list of available enum types for better type mapping</param>
    /// <returns>EmmyLua type annotation</returns>
    private static string ConvertToLuaType(string csharpType, List<Type>? availableEnums = null)
    {
        if (string.IsNullOrEmpty(csharpType))
            return "any";

        // Check if it's an enum type
        if (availableEnums != null)
        {
            var enumType = availableEnums.FirstOrDefault(e => e.Name == csharpType || e.FullName == csharpType);
            if (enumType != null)
                return enumType.Name;
        }

        return csharpType.ToLowerInvariant() switch
        {
            "string"                                                      => "string",
            "int" or "integer" or "int32" or "int64" or "long" or "short" => "integer",
            "float" or "double" or "decimal"                              => "number",
            "bool" or "boolean"                                           => "boolean",
            "void"                                                        => "nil",
            "table"                                                       => "table",
            "function"                                                    => "function",
            _ when csharpType.EndsWith("[]")                              => "table", // Arrays as tables
            _ when csharpType.StartsWith("List<")                         => "table", // Lists as tables
            _ when csharpType.StartsWith("Dictionary<")                   => "table", // Dictionaries as tables
            _                                                             => "any"    // Unknown types
        };
    }

    /// <summary>
    /// Generates and saves EmmyLua definition file to disk
    /// </summary>
    /// <param name="descriptors">List of script function descriptors</param>
    /// <param name="outputPath">Path where to save the definition file</param>
    /// <param name="enums">Optional list of enum types to include</param>
    public static void GenerateDefinitionFile(
        List<ScriptFunctionDescriptor> descriptors, string outputPath, List<Type>? enums = null
    )
    {
        ArgumentNullException.ThrowIfNull(descriptors);
        ArgumentException.ThrowIfNullOrEmpty(outputPath);

        var content = GenerateDefinitions(descriptors, enums);

        // Ensure directory exists
        var directory = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        File.WriteAllText(outputPath, content, Encoding.UTF8);
    }

    /// <summary>
    /// Generates separate definition files for each module
    /// </summary>
    /// <param name="descriptors">List of script function descriptors</param>
    /// <param name="outputDirectory">Directory where to save the definition files</param>
    /// <param name="enums">Optional list of enum types to include</param>
    public static void GenerateModuleDefinitionFiles(
        List<ScriptFunctionDescriptor> descriptors, string outputDirectory, List<Type>? enums = null
    )
    {
        ArgumentNullException.ThrowIfNull(descriptors);
        ArgumentException.ThrowIfNullOrEmpty(outputDirectory);

        if (!Directory.Exists(outputDirectory))
        {
            Directory.CreateDirectory(outputDirectory);
        }

        var moduleGroups = descriptors.GroupBy(d => d.ModuleName);

        foreach (var moduleGroup in moduleGroups)
        {
            var moduleName = moduleGroup.Key;
            var moduleDescriptors = moduleGroup.ToList();

            var fileName = $"{moduleName}.lua";
            var filePath = Path.Combine(outputDirectory, fileName);

            GenerateDefinitionFile(moduleDescriptors, filePath, enums);
        }
    }
}
